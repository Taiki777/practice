読書メモ

現場で役立つシステム設計の原則
・異なるクラスの重複したコードをなくすに置いて、参照関係にある場合はどっちのものを使うのか
・また、Goなどのコンストラクタがない？場合の言語において、共通のロジックを置いたクラスを作成しそこから個別のコンストラクタでオブジェクトを作成できない場合はどうやって対処するのか
・値オブジェクトは不変にすべき。値の変更が必要な場合は常に新しいオブジェクトを生成して返すべきとある。Go言語でのオブジェクトの作成方法とは？そもそもの仕様変更によって値を変える必要がある場合は？

第二章
・if文の条件式・計算式はメソッドとして抽出
・早期リターンを活用して、else句を書かない
・区分ごと(AdulltFee, ChildFeeなど)にクラスを分けるとロジックの整理がしやすい
・↑この状態だと毎回型を意識する必要があるので、interfaceを使って共通化する
・多態を使うと区分ごとのロジックをif文を使わずに記述できる
　　※多態とはインターフェース宣言と区分ごとの専用クラスを組み合わせて区分ごとに異なるクラスのオブジェクトを「同じ型」として扱う仕組み
・クラスとクラスは疎結合の方が独立性が高く、変更が他クラスに与える影響が少ない
・Javaの列挙型enumは多態をシンプルに記述する仕組み

第三章
・手続き型の設計はプログラムをデータ構造とロジックの記述に分ける
・↑これはデータクラスと機能クラスに分ける設計と同義
・データクラスを使うと同じ業務ロジックがあちこちに重複して書かれたり、どこに業務ロジックがあるのか見通しが悪くなる
ではどうすればいいか
・メソッドをロジックの置き場にする
　　・従来のデータクラスではインスタンス変数を返すだけのようなgetterがあった。
　　・オブジェクト指向ではgetterで使うインスタンス変数のロジックをメソッド内に書く
・メソッドでは必ずインスタンス変数を使う
・インスタンス変数が多いクラスに関連する業務ロジックを集めるとクラスが肥大化するので、その際は小さく分ける
・クラスを抽出していくとクラスの数が増える。そうなったらパッケージを使って整理する
・三層 + ドメインモデルでは業務ロジックをドメインモデルに記述する
　→　三層の記述がシンプルになり、業務ロジックの修正や拡張もドメインモデルに閉じ込めやすくなる

三層 + ドメインモデル表
プレゼンテーション層	UIなどの外部との入出力を持つ
アプリケーション層	業務機能のマクロな手順の記述
データソース層	データベースとの入出力を受け持つ
ドメインモデル	業務データと関連する業務ロジックを表現したドメインオブジェクトの集合

第四章
ドメインモデルを設計する方法
・業務の関心ごとを理解すればするほど、業務ロジックを体系的にわかりやすく整理できる
・分析(業務の関心ごと)と設計(コードの構造)を直接対応させて、両クラスを一致させることが重要
・手続き型の設計はトップダウン方式で、全体を俯瞰し定義してから分割しより詳細に定義を進めていく
・オブジェクト指向は反対にボトムアップ方式。部分に着目して、データと業務ロジックを一体にしたドメインオブジェクトを設計しながら全体を作っていく
オブジェクト思考設計
1. 全体を俯瞰する必要はあるので、パッケージ図や業務フロー図を使う。
2. 重要な部分から作っていく
3. 独立した部品を組みあせて機能を作る
・ドメインオブジェクトを部品として独立性を高めることで、変更を楽で安全にできる(部品として扱えるので他への影響が少ない)
・部品として分けるとは言っても、簡単に切り離せない上位部品と下位部品のように分けたり、機能中心でプログラムの処理が順番に依存するなど分解構造や時間的な依存を持たないよう、単体で動作確認ができる部品に分ける
・アプリケーション全体を設計するためには大量の業務知識から重要とそうでないものに分ける必要がある
→ 業務を分析するために関心ごとを　ヒト/モノ/コト　の三つに分類する
・コトは誰の何についての行動かとして出現するのでことに注目すると全体の関係を整理しやすい
・ドメインオブジェクトを使う側のコードがシンプルになるようにドメインオブジェクトにロジックを移動するなど改良しながら開発していく
・ドメインオブジェクトを設計するには業務知識が必要。でも初期段階などは業務についての理解がない。その場合でもわかる範囲からコードを書き始め、実際に開発を進める中で業務を学びながら段階的にコードを成長させるのがドメインモデルの効果的な設計手法
・より良いドメインモデルを設計するには業務についての理解が必要。その業務のマニュアル・書籍・専門家などから情報を得て、より業務知識を深めていくことが設計に重要

ドメインオブジェクトの基本の設計パターン
・値オブジェクト
・コレクションオブジェクト
・区分オブジェクト
・列挙型の集合操作

業務の関心ごとのパターン(曖昧なのでNoteBookLMに聞く)
・口座パターン
・期日パターン
・方針パターン
・状態パターン（ルールの集合を扱う。ルールの配列を持って、ループで全てのルールを判断させるなど）

第五章
サービスクラスの設計方法
・業務ロジックをドメインオブジェクトに任せる
・画面の複雑さをサービスクラスに持ち込ませない
・データベースの都合からサービスクラスを独立させる

・業務ロジックを追加したくなったら、既存のドメインオブジェクトを改良するいい機会だと思い、ドメインオブジェクトを見直す。サービスクラスに書くと重複の可能性が生まれる
・サービスクラスは小さく分ける。具体的に参照系(GET)と登録系(CREATE, UPDATEなど)を分ける
→ 例えば預金引き出し処理では残高の照会・指定金額が引き出し可能かの判定・残高の変更の3つの部品に分けて、実際の参照機能とは別で作成する

第六章
データベース設計について
・NOT NULL制約を使う。NULL値が必要なカラムを見つけたら別のテーブルに移動させる（←これが正しいかは不明。検証が必要）
・一意性制約でテータの重複を防ぐ
・外部キー制約でテーブル間の関係を明確にする（← TiDBなどではサポートされてなかった。外部キーを使わない設計もありそう）
・過去の記録を変更する場合はUPDATEを使わず、取り消し→追加を行う。←なぜUPDATEはだめ？
→ 記録の同時性に違反するから。また、UPDATEは新しいデータには適用できないので、INSERTするなどの追加の仕組みが必要になる
・カラムを追加する際はテーブルを追加する
・非同期メッセージングでシステム間の連携を疎結合にする
・ドメインオブジェクトとデータベースは似ているが、違うもの。それらは独立させる必要がある。SQLMappetを使うとオブジェクト設計とテーブル設計の独立性を保ちやすくなる。でもマッピングの自動化は不要な制約を持ち込むのでよくない
・業務ロジックはオブジェクトで、事実の記録はテーブルで！

第七章
画面とドメインオブジェクトを連動させる設計
・画面に表示する文字列でドメインオブジェクトに入れた方がいいものがある（情報の文字列表現: 検索が見つかりませんでしたなど。逆に段落や改行のHTMLタグはドメインオブジェクトに含めるべきではない）
・画面を表示するロジックにif文が入り始めたらドメインオブジェクトに書くべきロジックの可能性があるため、注意する
・画面に表示する項目とドメインオブジェクトの中身は一致させる。順番や項目数が違うのは良くない
画面デザインの4原則
1. 近接: 関係のある情報は近づける。関係の無い情報は離す。
2. 整列: 同じ意味のものは同じラインに揃える。意味が異なれば異なるラインに揃える
3. 対比: 意味の重みの違いを文字の大きさや色の違いで区別する。
4. 反復: 同じ意味は同じパターンで視覚化する
・近接したグループはドメインオブジェクトの単位と一致するはず。画面上の空白で分離された複数の情報が1つのドメインオブジェクトにまとまっている場合は利用者の関心事の理解として問題あり。
・整列、特にインデントはグルーピングの良い手がかり。インデントされた部分を別のオブジェクトとして括り出すことで関心事を適切に表現できる
・パッケージ構造でも同様に、重要な項目は上の方で宣言する。
↑これら画面とドメインオブジェクトの連動は画面がタスクベースの場合


第八章
Web APIでアプリケーション間をつなぐ
・クエリパラメータはオプショナルな絞り込み条件として使うのが基本。基本的にはリソースを一意に識別する番号や、リソースのグループを指定するカテゴリー名はクエリよりもURIのパスで表現すべき。
・POSTとPUTは本来はどちらも登録を意味するが、「識別体系を事前に知っているかどうか」による。リクエストする側がサーバ側のアプリケーションのリソースの識別体系を事前に知っている必要があるのがPUT、そうじゃ無いのがPOST。
・つまりPUTの方が接続先の識別体系を知っている必要があるため、結合が密になる。
・データの登録はできるだけPOSTで行う方がアプリケーションの独立性が高くなり、将来の修正や拡張の影響を小さくできる。
・https://api.example.com/books/1234/updates ← このような方法でPOSTでも実現できる
↑ データの登録と相手の状態を同時に扱うPUTよりも、POSTによる登録とGETによる状態の取得を組み合わせることが、アプリケーション間の依存度を下げる好ましい設計
・DELETEもPUT同様にアプリケーションが密に結合するので、/1234/deletionでPOSTメソッドで削除を依頼できる
良いWeb APIとは何か
・大は小を兼ねるようなAPIは利用者にとって不必要な理解する項目が増えて負担になる。提供側もif文が増えたりなど複雑になる。
・APIの粒度が小さいと実現できる機能が豊富だったり、拡張がしやすいなどの利点があるが、複雑性がます
・APIの粒度が大きいと簡単に組み立てることができるが、実現できる機能が限定される
↑つまり良いWeb APIとは組み立ての多様性を維持しつつ、複雑になり過ぎない粒度にする
・良いWeb APIの設計として、共通APIと個別対応のAPIを明確にする。個別対応のAPIが複数から使われているなら共通のAPIに移動させるなど進化させることで、短期的にはコストがかかるが、中長期的には運用が楽になる（共通APIは拡張や修正されやすい）


第九章
オブジェクト指向の開発プロセス
・分析と設計は同じ人がやる
・対象業務に興味関心を持って設計や構造を考えられる技術者に価値がある


第十章
オブジェクト指向の学び方
・既存コードを改善しながらオブジェクト指向設計を学ぶ
リファクタリングを行う。以下の三つのコードがあればリファクタリングのチャンス
・コードの重複
・長いメソッド
・巨大なクラス

用語(ちょっと曖昧)
・オブジェクト指向
メリット
・クラスやテストコードが業務の関心事を表現するため、ソースコード以外にドキュメントの必要性が減る

・値オブジェクト
・コレクションオブジェクト
・区分オブジェクト
・ドメインオブジェクト（関連する業務データと業務ロジックを一つにまとめたオブジェクト）
・ドメインモデル（ドメインオブジェクトを整理したもの）
・契約による設計（nullを渡さない/返さない・使う側が事前に確認する・約束を守った上で異常が起きた場合は例外で通知）
・防御的プログラミング
・シナリオクラス（サービスクラスを組みあせた複合的な機能を持つクラス）
・非同期メッセージング
・イベントソーシング（コトの発生を起点にするアプリケーション設計）← 機能要件次第。課題が多そうなのでどう言う場面で活用できるか要チェック
・アノテーション
・SQL Mappter
・タスクベースユーザーインタフェース（スマホの普及やクラウドなどの小さい単位で高頻度の通信でタスクベースが増えていきている）

感想
・全体として設計思想、フロントエンド、バックエンド全てにおいて小さく分けることを強調しているように感じた。



1. 書籍からの学び・気づき（概念の理解）
ここでは、本書が提示する「変更を楽で安全にする」ための核心的なコンセプトを整理します。
• 「手続き型設計」の限界と副作用
    ◦ データを保持するだけの「データクラス」と、処理を行う「機能クラス」を分ける設計が、いかに業務ロジックの散乱や重複を招くか。
    ◦ その結果、修正箇所を特定するために広範囲のコードを調べる必要が生じ、変更の安全性が損なわれる点。
• ドメインモデルによるロジックの一元管理
    ◦ データとそのデータを使う判断・加工・計算のロジックを一つの「ドメインオブジェクト」にまとめるという考え方。
    ◦ 値オブジェクト（数値や文字列をラッピングする）、コレクションオブジェクト（List操作を隠蔽する）、区分オブジェクト（Enumで分岐を整理する）といった基本パターンの有用性。
• コードを「業務の説明書」にする活動
    ◦ クラス名やメソッド名を実際の業務用語と一致させることで、コードがそのまま「業務マニュアル」になるという気づき。
    ◦ 「ヒト・モノ・コト」の分類、特に**「コト（事象）」**に着目することで、業務ルールの背後にある構造を整理できる点。
2. 担当プロダクト視点での学び・気づき（現状の分析）
読んだ内容を、現在担当しているプロダクトのコードや設計に当てはめて分析した内容を書きます。ここが評価のポイントになります。
• ロジックの「置き場所」の現状確認
    ◦ プロダクトのサービス層（アプリケーション層）が、詳細なif文や計算式で肥大化した「トランザクションスクリプト」になっていないか。
    ◦ 特定の業務ルールを変更したいとき、何箇所のクラスを修正する必要があるか（現状の散乱度の自己評価）。
• ドメイン用語と実装の乖離
    ◦ ソースコードの中に、業務知識がないと理解できない「謎のフラグ」や「省略された変数名」がどれくらい存在するか。
    ◦ プロダクトで扱っている重要な「コト（注文、契約、配送など）」が、単一の大きなテーブルとしてではなく、意味のあるオブジェクトとして独立して表現されているか。
• 技術的な関心事との混ざり具合
    ◦ 画面の複雑な表示ロジックや、データベースのテーブル構造に、業務ロジックが引きずられていないか。
    ◦ SQLのINSERTやUPDATEといった操作が、業務の意図（例：残高を更新する）を隠してしまっていないか。
3. 今後のアクション（記事の締めくくり）
学びを得た上で、今後プロダクトをどう良くしていきたいかを記述します。
• 小さなリファクタリングの提案
    ◦ まずは、プリミティブ型（intやString）で扱っている特定の項目（金額、電話番号、状態など）を「値オブジェクト」として切り出してみる。
    ◦ 複雑なif文を「ガード節（早期リターン）」や「区分オブジェクト」に置き換えて、見通しを改善する。
• ドメイン知識の言語化
    ◦ 業務の専門家が使っている言葉を積極的にキャッチし、コード内の命名に反映させるサイクルを作る