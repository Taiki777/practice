# 【書籍】達人に学ぶDB設計徹底指南書 第2版から学んだDB設計の要点に当てはめる）

## 概要（3〜5行）
- 目的：現場で飛び交う「正規化」「論理設計/物理設計」「レプリケーション」「インデックス」などの概念を、定義だけでなく“判断基準（トレードオフ）”として使えるようにする。
- 読んだ範囲：第1章〜第7章（メモ中心：3層スキーマ、論理/物理、冗長化、正規化、性能、アンチパターン）
- 結論：DB設計は **論理（意味/整合性）→物理（性能/運用）** の順で組み立てつつ、最後は **要件と運用の平衡点** を作る仕事。

## TL;DR（要点3つ）
- **DOA（データ→処理）** が基本。まずデータの意味と制約を決めると、実装・運用がブレにくい。
- **正規化は“意味を分ける”技術**。一方で結合コストは増えるので、性能はインデックス/統計/計測で詰め、それでも無理なら非正規化を検討する。
- 可用性は **RAID（ディスク）/レプリケーション（冗長化）/バックアップ（復旧）** を混ぜない。役割が違う。

---

## 書籍からの学び・気づき（結論→理由→例）

### 1) DOA（Data Oriented Approach）が基本
- 結論：システム開発では、原則として **POAよりDOA（データ設計→処理設計）**。
- 理由：処理は変わりやすいがデータは残り続ける。データの意味・制約が曖昧だと、後から仕様変更が来た時に破綻しやすい。
- 例：契約/取引先/ユーザーの“定義”が曖昧なまま実装すると、画面やAPIは作れても、後から整合性・集計・検索で詰む。

### 2) 3層スキーマは「変更耐性」の緩衝材
- 結論：DBは **外部スキーマ（ユーザー視点）/概念スキーマ（開発者視点）/内部スキーマ（DBMS視点）** に分けて考える。
- 理由：外（要望）と内（制約）を直結すると変更に弱い。概念スキーマが中間にあることで、UI/API変更と物理変更の影響を分離できる。
- 例：画面の見せ方が変わっても、概念（テーブルの意味）を安易に変えない／逆に物理（インデックスなど）を変えても外部I/Fに波及させない。

### 3) 論理設計→物理設計の順（料理と器）
- 結論：**論理設計（意味と制約）を先に**、物理設計（格納や性能）は後に。
- 理由：論理設計は本来、CPU/ディスク/SQL方言などの物理制約に依存しない。まず“あるべき姿”を作ってから現実に合わせる。
- 例：料理（論理）を作ってから器（物理）を選ぶ。器から選ぶと、料理が歪む。

### 4) 可用性：RAID / レプリケーション / バックアップは役割が違う
- 結論：可用性は「冗長化（止めない）」と「復旧（戻す）」を分けて設計する。
- 理由：RAIDは1台内のディスク故障対策、レプリケーションはサーバ故障や読み取り分散、バックアップは誤操作や破壊からの復旧。目的が違う。
- 例：
  - RAID：ディスクが死んでもサービス継続（ただしサーバが死ぬと終わる）
  - レプリ：サーバが死んでも切替（ただし論理破壊は複製される）
  - バックアップ：誤DELETEなど論理破壊から復旧できる（ただし復旧には時間がかかる）

### 5) 正規化は原則3NF、非正規化は最後の手段
- 結論：原則 **第3正規形まで** を目指して冗長性と不整合を消し、性能が厳しい場合のみ非正規化を検討する。
- 理由：正規化は更新時異常（挿入・更新・削除の矛盾）を減らし、テーブルの意味を明確にする。一方で結合が増えるので、性能はまず他の手段で詰める。
- 例：コードと名称が同居する（推移依存）と、名称変更時に更新漏れが起きる。

### 6) DB性能の主要因は「I/O」「結合」「インデックス/統計」
- 結論：性能は“正規化＝遅い”だけでは語れない。I/O分散、結合、インデックス、統計情報の総合戦。
- 理由：結合が増えても、適切なインデックスや統計があれば十分速いことは多い。逆にインデックスを貼りすぎると更新性能と運用コストが落ちる。
- 例：WHERE/JOIN列に貼る、カーディナリティが高い列が基本。ただし貼りすぎると更新が重くなる。

---

## 用語メモ（現場で使う範囲だけ）
- 論理設計：エンティティ抽出→定義→正規化→ER図
- 物理設計：テーブル→インデックス→サイジング→冗長構成→物理配置
- カーディナリティ：列の値の種類数（≒選択性）。高いほどインデックスが効きやすい傾向
- 統計情報：オプティマイザが実行計画を選ぶ材料
- RAID：1台内ディスク冗長/性能
- レプリケーション：複数サーバ冗長/読み取り分散（遅延や運用コストが増える）
- バックアップ：復旧のため（フル＋差分/増分のトレードオフ）

---

## プロダクト視点での学び・気づき（観察→推測→次の一手）

### 観察（事実）
- [{プロダクト名}] の {環境名} でDBサーバが複数台（例：DB1/DB2）存在していた。
- 主要テーブル（例：[会社/契約/ユーザー/連絡先…]）の設計を「正規形・制約・インデックス」の観点でまだ棚卸しできていない。

### 推測（なぜそうなっている？）
- DB1/DB2は **primary/standby（またはread replica）** の可能性がある。
- テーブル設計には、整合性（正規化）と検索性能（JOIN/INDEX）のトレードオフ判断が含まれているはずで、背景を推測できると設計意図の理解が進む。

### 次の一手（1つだけ）
- **主要3ユースケース（画面/API）を選び、対応するSQLのEXPLAINとインデックス有無を棚卸し**する。
  - 目的：正規化によるJOIN増加が、実際にボトルネックになっているかを“計測”で判断できる状態にする。

### リスク/トレードオフ（1行）
- インデックス追加は参照性能を上げるが、更新性能/運用コストが増える。非正規化はさらに整合性リスクが増えるため「更新経路が1箇所」が条件。

---

## 明日から変えること（行動1つ）
- PR/設計レビュー時に「DB観点チェック」を1行入れる（制約・インデックス・意味の分離）。

---

## 付録：確認チェックリスト（レビュー用）
- [ ] テーブルが“1つの意味”になっているか（ダブルミーニングがないか）
- [ ] 1セルに複数値が入っていないか（CSV/JSON詰め込み）→ 1NF
- [ ] コードと名称が同居していないか（推移依存）→ 3NF
- [ ] UNIQUE / FK / NOT NULL が適切か（アプリのバリデーションだけに寄っていないか）
- [ ] 主要クエリのWHERE/JOIN列にインデックスがあるか（貼りすぎにも注意）
- [ ] 非正規化しているなら更新経路が1箇所に絞れているか（破綻しやすい）
- [ ] 可用性の役割分担（RAID/レプリ/バックアップ）が整理できているか

---

## 付録：調査で使うSQL例（必要なら）
### インデックス確認（MySQL例）
SHOW INDEX FROM {table_name};

### 実行計画（MySQL例）
EXPLAIN {sql};

### 統計情報（MySQL例：実運用は権限注意）
ANALYZE TABLE {table_name};

---

## 感想（短く）
- 「正規化＝正しい」「非正規化＝悪」ではなく、要件・運用・性能の制約の中で“平衡点”を作る仕事だと腹落ちした。
- 今後は、テーブル定義を見る時に「第何正規形か」よりも「どの更新時異常を避けたい設計か／何を犠牲にしているか」を言語化できるようにしたい。
-> トレードオフの関係があるため、何を犠牲にし何を優先したのか
